:set -package comonad

import Control.Applicative
import Control.Monad
import Control.Comonad
import Data.Char
import Data.List

-- https://old.reddit.com/r/haskell/comments/fcjrt3/is_there_any_working_ide_for_haskell_out_there/fjc6et4/
:set -Wall -Wincomplete-record-updates 
:set -Wno-type-defaults

-- https://limperg.de/ghc-extensions/
:set prompt ">" 
:set -XExplicitForAll
:set -XFunctionalDependencies
:set -XViewPatterns
:set -XPatternSynonyms
:set -XKindSignatures
:set -XLambdaCase
:set -XNamedFieldPuns
:set -XRecordWildCards
:set -XFunctionalDependencies
:set -XGADTSyntax
:set -XGADTs
:set -XConstraintKinds
:set -XDataKinds
:set -XNumericUnderscores
:set -XGeneralizedNewtypeDeriving
:set -XInstanceSigs
:set -XConstrainedClassMethods
:set -XExistentialQuantification
:set -XTypeFamilies
:set -XDefaultSignatures
:set -XDisambiguateRecordFields
:set -XDuplicateRecordFields
-- https://codetalk.io/posts/2020-04-05-common-json-patterns-in-haskell-rust-and-javascript.html#get-a-field
-- Allows us to have multiple record fields of the same name in scope. Prepend name with '#'.
:set -XOverloadedLabels
:set -XBangPatterns
:set -XApplicativeDo
:set -XNegativeLiterals
:set -XTypeOperators
-- https://stackoverflow.com/questions/50788238/haskell-multi-way-if-expressions-need-multiwayif-turned-on
:set -XMultiWayIf
-- https://sodocumentation.net/haskell/topic/1274/common-ghc-language-extensions
:set -XOverloadedStrings
:set -XUnicodeSyntax
:set -XBinaryLiterals
:set -XOverloadedLists
-- https://rebeccaskinner.net/posts/2021-08-25-introduction-to-type-level-programming.html
:set -XPolyKinds
-- :set -XAllowAmbiguousTypes

-- -*- mode: haskell; -*-
-- Begin copied material.
-- <http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/dot-squashed.ghci641>
:{
:def redir \varcmd -> return $
        case break Data.Char.isSpace varcmd of
            (var,_:cmd) -> unlines
                [":set -fno-print-bind-result"
                ,"tmp <- System.Directory.getTemporaryDirectory"
                ,"(f,h) <- System.IO.openTempFile tmp \"ghci\""
                ,"sto <- GHC.IO.Handle.hDuplicate System.IO.stdout"
                ,"GHC.IO.Handle.hDuplicateTo h System.IO.stdout"
                ,"System.IO.hClose h"
                ,cmd
                ,"GHC.IO.Handle.hDuplicateTo sto System.IO.stdout"
                ,"let readFileNow f = readFile f >>= \\t->Data.List.length t `seq` return t"
                ,var++" <- readFileNow f"
                ,"System.Directory.removeFile f"
                ]
            _ -> "putStrLn \"usage: :redir <var> <cmd>\""
:}

--- Integration with the hlint code style tool
:{
:def hlint \extra -> return $ unlines
        [":unset +t +s"
        ,":set -w"
        ,":redir hlintvar1 :show modules"
        ,":cmd return $ \":! hlint \" ++ unwords (map (takeWhile (/=',') . drop 2 . dropWhile (/= '(')) $ lines hlintvar1) ++ \" \" ++ " ++ show extra
        ,":set +t +s -Wall"
        ]
:}
